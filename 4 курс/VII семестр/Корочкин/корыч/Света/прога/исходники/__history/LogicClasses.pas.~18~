unit LogicClasses;

interface
uses classes, Sysutils, Contnrs, Myclasses, Forms;

Type TClient=Class(TObject)
private
  mNumber: integer;
  mWaitTime: integer;
  mTotalTime: integer;
  mWaitTimer: integer;
  mNeedTer: Boolean;
  mNeedHir: Boolean;
  mNeedPsi: Boolean;
public
  Constructor Create(cNumber: integer);
  Destructor Destroy; override;
  property TotalTime: integer read mTotalTime write mTotalTime;
  property WaitTime: integer read mWaitTime write mWaitTime;
  property WaitTimer: integer read mWaitTimer write mWaitTimer;
  procedure SetMDs;
end;

Type TLogicNode=Class(TObject)
private
  mQueue: integer;
  mActive: Boolean;
  mWaitTime: integer;
  mWorkTime: integer;
  mInfoControls: TInfoControls;
  mClientList: TObjectList;
  mClient: TClient;
public
  Constructor Create(cName: string; cForm: TForm);
  Destructor Destroy; override;
  property Ctrl: TInfoControls read mInfoControls write mInfoControls;
  property ClientList: TObjectList read mClientList write mClientList;
  property Client: TClient read mClient write mClient;
  property Active: Boolean read mActive write mActive;
  procedure UpdateInfo;
  procedure Tick(dt: integer);
end;

procedure ClientFromQueueToNode(Node: TLogicNode);
procedure ClientFromNodeToQueue(NodeFrom, NodeTo: TLogicNode);

implementation

Constructor TLogicNode.Create(cName: string; cForm: TForm);
begin
  mInfoControls := TInfoControls.Create(cName, cForm);
  mQueue := 0;
  mActive := false;
  mWaitTime := 0;
  mWorkTime := 0;
  mClient := nil;
  mClientList := TObjectList.Create;
end;

Destructor TLogicNode.Destroy;
begin
  inherited;
end;

procedure TLogicNode.UpdateInfo;
begin
  mInfoControls.QueueInfo.Edit.Text := IntToStr(mQueue)+ ' чел.';
  if mActive then mInfoControls.StateInfo.Edit.Text := 'Работа'
  else mInfoControls.StateInfo.Edit.Text := 'Ожидание';
  mInfoControls.WaitInfo.Edit.Text := FloatToStrF(mWaitTime/60,ffFixed,3,2) + ' мин.';
  mInfoControls.WorkInfo.Edit.Text := FloatToStrF(mWorkTime/60,ffFixed,3,2) + ' мин.';
end;

procedure TLogicNode.Tick(dt: integer);
begin
  mQueue := mClientList.Count;
  if (mQueue>0)and(mActive=false) then ClientFromQueueToNode(Self);
  if mActive then mWorkTime := mWorkTime + dt
  else mWaitTime := mWaitTime + dt;
end;

Constructor TClient.Create(cNumber: integer);
begin
  mNumber := cNumber;
  mWaitTime := 0;
  mTotalTime := 0;
  mWaitTimer := -1;
  mNeedTer := False;
  mNeedHir := False;
  mNeedPsi := False;
end;

Destructor TClient.Destroy;
begin
  inherited;
end;

procedure TClient.SetMDs;
begin
  if Random(1) = 1 then mNeedTer := true;
  if Random(1) = 1 then mNeedHir := true;
  if Random(1) = 1 then mNeedPsi := true;
end;

procedure ClientFromQueueToNode(Node: TLogicNode);
begin
   Node.Client := node.ClientList[0] as TClient;
   Node.ClientList.Extract(Node.ClientList.First);
   Node.Active := true;
end;

procedure ClientFromNodeToQueue(NodeFrom, NodeTo: TLogicNode);
begin
  NodeTo.ClientList.Add(NodeFrom.Client);
  NodeFrom.Client := nil;
  NodeFrom.Active := false; 
end;

end.
