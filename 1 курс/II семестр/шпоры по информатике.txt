1 Ссылочные типы. Cсылочный тип (указатель) определяет множество значений, которые указывают на динамические  переменные  определенного  типа, называемого  базовым  типом.  Переменная ссылочного типа содержит адрес динамической переменной в памяти. ссылочный тип ^ базовый тип. Если базовый тип является еще не  описанным идентификатором, то он должен быть описан в той же самой части описания типов, что и тип указатель. Переменной-указателю можно присвоить значение с помощью процедуры New, операции @ или функции Ptr. Процедура New отводит новую область памяти в динамически распределяемой области для динамических  переменных  и сохраняет адрес этой области в переменной  указателя. Операция @ ориентирует переменную-указатель на область памяти, содержащую существующую переменную, включая и те переменные,  которые имеют идентификаторы. Функция Ptr ориентирует переменную-указатель на определенный адрес в памят. Зарезервированное слово nil обозначает константу со значением указателя, которая ни на что не указывает.
2 Тип Pointer. Встроенный тип  Pointer  обозначает  нетипизированный указатель, то есть указатель, который не указывает ни на какой опреденный тип. Переменные типа Pointer могут быть разыменованы: указание символа ^ после такой переменной вызывает появление ошибки. Как  и значение,  обозначаемое словом nil,  значения типа Pointer совместимы со всеми другими типами указателей.
3 Переменные-указатели и динамические переменные. Значением переменной-указателя является  или  nil  (то  есть пустое значение), или адрес значения, указывающий на динамическу переменную. Ссылка на динамическую переменную,  на которую указывает переменная-указатель,  записывается  в  виде  переменной-указателя,  после которой ставится символ указателя (^). Динамические переменные и значения их указателей создаются с помощью стандартных процедур New и GetMem. Вы можете использовать операцию @ и стандартную функцию Ptr для создания значений указателя, которые рассматриваются как указатели динамических переменных. Значение nil не указывает ни на какую  переменную.  Если  вы попытаетесь получить доступ к динамической переменной при неопределенном значении указателя или указателе,  равном nil, результат будет неопределенным. Приведем несколько  примеров  ссылок (указателей) на динамические переменные:P1^; P1.Sibling^.
4 Константы ссылочного типа. Описание константы  ссылочного  типа  может содержать только значение nil (пусто). Приведем несколько примеров:
	 type
                TDirection = (Left, Right, Up, Down);
                TStringPtr = ^String;
                TNodePtr = ^Node;
                TNode = record
                          Next: NodePtr;
                          Symbol: StringPtr;
                          Value: Direction;
                        end;
             const
                  S1: string[4] = 'DOWN';
                  S2: string[2] = 'UP';
                  S3: string[5] = 'RIGHT';
                  S4: string[4] = 'LEFT';
                  N1: Node = (Next: nil; Symbol: @S1; Value: Down);
                  N2: Node = (Next: @N1; Symbol: @S2; Value: Up);
                  N3: Node = (Next: @N2; Symbol: @S3; Value: Right);
                  N2: Node = (Next: @N3; Symbol: @S4; Value: Left);
                  DirectionTable: NodePtr = @N4;
Если разрешен расширенный синтаксис (указана директива  компилятора {$X+}), типизированная константа типа PChar может инициализироваться строковой константой, например:
             const
                Message: PChar = 'Программа завершена';
                Prompt: PChar = 'Введите значения: ';
                Digits: array[0..9] of PChar = (
                    'Ноль', 'Один', 'Два', 'Три', 'Четыре',
                    'Пять', 'Шесть', 'Семь', 'Восемь', 'Девять');
Результатом будет то,  что указатель теперь указывает на область памяти,  содержащую копию строкового литерала с завершающим нулем. 
5 Операция @.
Операция @ используется как адресный коэффициент переменной,  процедуры,  функции или метода. Пробел запрещен.
адресный коэффициент @ ---ссылка а переменную/идентиф процедуры/идент функции/уточнен. идент. метода
Операция @ возвращает адрес операнда. Использование операции @ для переменной. Использование операции @ для обычной переменной (не параметра) не вызывает никаких сложностей.  Применение @ к ссылке на переменную возвращает указатель на переменную. Введем описания:type
               TwoChar = array[0..1] of char;
             var
               Int: integer;
               TwoCharPtr: ^TwoChar;
             TwoCharPtr := @Int;
Тип получаемого в результате указатель управляется  директивой компилятора  $T:  в  состоянии {$T-} (по умолчанию) типом результата будет Pointer. В состоянии {$T+} типом результата будет ^T,  где T -тип ссылки на переменную. Использование операции @ для процедуры или функции или метода. Вы можете применять операцию @ к процедуре,  функции или методу. При этом вы получите указатель на точку входа подпрограммы. Независимо от состояния $T, типом полученного в результате указателя всегда  будет Pointer.  Другими словами,  результатом всегда является нетипизированный указатель, совместимый со всеми другими      ссылочными типами. При применении операции @ к методу метод должен задаваться с помощью уточненного идентификатора (идентификатора объектного типа, за которым следует точка и идентификатор метода).
6 Процедуры динамического распределения памяти.
Dispose-уничтожает динамическую переменную. FrееМем-уничтожает динамическую  переменную данного размера.  GetМем-создает новую динамическую  переменную  заданного  размера и устанавливает на нее переменную-указатель. MахАvail-возвращает размер  наибольшего непрерывного свободного модуля в динамически распределяемой области памяти, соответствующий размеру наибольшей динамической переменной,  которая может быть выделена при  обращении  в МахAvail. МемАvail-возвращает количество  имеющихся  в динамически  распределяемой   области   свободных байт. New-создает новую динамическую переменную и устанавливает на нее переменную-указатель.
7 Функции для работы с указателями и адресами. Аddr  Возвращает адрес заданного объекта. CSeg  Возвращает текущее значение регистра CS. DSeg  Возвращает текущее значение регистра DS. Оfs     Возвращает смещение для заданного объекта. Ptr Преобразует адрес базового сегмента и  смещение в значение типа указатель. Seg Возвращает сегмент для заданного объекта. SPtr    Возвращает текущее значение регистра SР. SSeg Возвращает текущее значение регистра SS.
8 работа с динамическими структурами данных.
При работе используются 3 операции: добавление, исключение, поиск элемента.
Ввести с клавиатуры и вывести на экран среднее значение. 
P – указатель, t - объект.
type
Pchain = ^ integ;
Integ = record
Num: real;
Next: Pchain;
end;
var
Ptr, Head, Tail: Pchain;
N: integer;   {сколько чисел}
St: string;   {для ввода числа}
Sum: real;   {суммирование}
Procedure MK_Chain (var L: integer);
var
V: real, Code: integer;
begin
L := 0,
Head := nil;
Tail := nil;
Repeat ReadLn (St),
if St <> ‘.’ Then 
begin
Val (St, V, Code);
if Code <> 0 then
WriteLn (‘введенная информация не соответствует числу’)
Else begin
New (Ptr);   {адрес выделенного кусочка памяти}
Ptr ^. Num := V;
Ptr.^ Next := nil;
L := L+1;
if  Tail <> nil then
Tail .^ Next := Ptr;  {ссылка берется с Ptr }
Tail := Ptr;   {заполняем следующий элемент}
if  Head = nil then 
Head := ptr;
end;
end;
until St = ‘.’;
end;
Begin	MK_Chain(N);
Sum := 0;   {назначение значения}
Ptr := Head;   {адрес 1го элемента динамической памяти}
While Ptr <> nil do
Begin
Sum := Sum + Ptr^.num;
Head := Ptr^.Next;   {голова на 2ом элементе}
Dispose (ptr0;  {все, что занимал 1ый элемент выкинули}
Ptr := Head;
End;
If N <> 0 then
WriteLn (‘ ‘ , Sum/ N);
Else
WriteLn (‘пусой’);
End.  
9 строка с завершающим нулем. В Borland  Pascal строки обычного типа (String) хранятся как байт длины,  за которым следует последовательность символов. Максимальная длина строки в Паскале равна 255 символам.  Таким образом, строка Паскаля занимает от 1 до 256 байт памяти. Строки с завершающим нулем не содержат байта  длины.  Вместо этого  они  состоят из последовательности ненулевых символов,  за которыми следует символ NULL (#0).  Никаких ограничений на  длину строк с завершающим нулем не накладывается, но 16-разрядная архитектура DOS и Windows ограничивает их размер 65535 символами.
10 Тип PChar. Для представления указателя на строку с завершающим нулем  в Borland Pascal имеется предопределенный тип PChar. В блоке System данный тип описывается следующим образом: type PChar = ^Char; Borland Pascal поддерживает набор расширенных правил, позволяющих работать  со  строками с завершающим нулем,  используя тип PChar. 
11 Операции над символьными указателями. Расширенный синтаксис поддерживает несколько операций с  указателями  на  PChar. Для увеличения и уменьшения смещения указателя можно использовать операции + и -.  Минус можно также  использовать  для  вычисления расстояния (разности) между двумя символьными указателями. Если P и Q - это значения типа PChar,  а I - значение типа Word,  то допустимы следующие конструкции:
P + I Сложение I со смещением P; I + P Сложение I со смещением P; P - I  Вычитание I из смещения P; P - Q  Вычитает смещение Q из смещения P.      
Операции P  + I и I + P складывает I c адресом,  заданным P, создавая указатель, ссылающийся на I символов после P. Операция P- I вычитает I из адреса, заданного P, создавая указатель, ссылающийся на I символов перед P. Операция P - Q вычитает расстояние между Q (младший адрес) и P (старший адрес),  создавая в результате значение типа Word, показывающее число символов между Q и P.  


12 Методы освобождения областей динамически распределяемой памяти. Динамические переменные, сохраняемые в динамически распределяемой области, освобождаются одним из двух следующих способов: С помощью процедур Dispose или FrееМем; С помощью процедур Маrk и Rеlеаsе. Простейшей схемой использования  процедур  Маrk  и  Rеlеаsе, например, является выполнение следующих операторов:
             New(Ptr1);
             New(Ptr2);
             Mark(P);
             New(Ptr3);
             New(Ptr4);
             New(Ptr5);
          HeapEnd   -->--------------------------- Верхняя граница
                       ¦                          ¦ памяти
        HeapPtr   -->+--------------------------+
                       ¦   содержимое Ptr5^       ¦
              Ptr5  -->+--------------------------+
                       ¦   содержимое Ptr4^       ¦
              Ptr4  -->+--------------------------+
                       ¦   содержимое Ptr3^       ¦
              Ptr3  -->+--------------------------+
                       ¦   содержимое Ptr2^       ¦
              Ptr2  -->+--------------------------+
                       ¦   содержимое Ptr1^       ¦
              Ptr1  -->L--------------------------- Нижняя граница памят
Оператор Маrk(P) отмечает состояние динамически распределяемой  области непосредственно перед выделением памяти для переменной Ptr3. Если  выполняется оператор Rеleаsе(P)
          HeapEnd   -->--------------------------- Верхняя граница
                       ¦                          ¦ памяти      
                       ¦                          ¦
          HeapPtr   -->+--------------------------+
                       ¦   содержимое Ptr2^       ¦
              Ptr2  -->+--------------------------+
                       ¦   содержимое Ptr1^       ¦
              Ptr1  -->L--------------------------- Нижняя граница памяти
Процедур  Dispose и FrееMem. Эти процедуры позволяют в любой момент освободить память, выделенную для любой динамической переменной, на которую ссылается указатель.
Когда с помощью процедур Dispose и FrееМем освобождается память,  отведенная для динамической переменной, не являющаяся "самой верхней" переменной в динамически распределяемой  области, то динамически  распределяемая область становится фрагментированной. Предположим, что выполнялась та же последовательности операторов,
что  и  в  предыдущем  примере.  Тогда после выполнения процедуры Dispose(Ptr3) в центре динамически распределяемой  области памяти образуется незанятое пространство ("дыра").  
          HeapEnd   -->--------------------------- Верхняя граница
                       ¦                          ¦ памяти
                       ¦                          ¦
          HeapPtr   -->+--------------------------+
                       ¦   содержимое Ptr5^       ¦
              Ptr5  -->+--------------------------+
                       ¦   содержимое Ptr4^       ¦
              Ptr4  -->+--------------------------+
                       ¦--------------------------¦
                       ¦--------------------------¦
                       +--------------------------+
                       ¦   содержимое Ptr2^       ¦
              Ptr2  -->+--------------------------+
                       ¦   содержимое Ptr1^       ¦
              Ptr1  -->L---------- Нижняя граница памяти
Release не используется без Mark, а Mark без Release используется.
13 Процедуры и функции. Процедура – оформленный особым образом фрагмент программы, имеющий имя. Функция – оформленный особым образом фрагмент программы.Процедуры и функции позволяют включать в основной  програмный  блок  дополнительные  блоки.  Каждое  описание процедуры или функции содержит заголовок,  за которым следует программный блок.Процедура  активизируется с помощью оператора процедуры.  Функция       активизируется при вычислении выражения,  содержащего вызов функции, и возвращаемое функцией значение подставляется в это выражение. Описание процедуры позволяет связать идентификатор с  процедурным  блоком.  Процедуру  можно  затем активизировать с помощью оператора процедуры.
Описание процедуры—заголовок процедуры---;---тело подпрограммы---;
Заголовок процедуры---procedure----идентиф./уточн.иден.----список формаль.парам.
Блок----------------------------------------модуль------------
|----------	Near  ----  ;----	|----------	forward---|  |
|---------	Far--------|	|----------	external---|  |
|----------	Export--	|	|---------	asm--------|  |
|----------	Interrupt	|	                                   |	
------------------inline------------------------------------|
Процедура активизируется с помощью  оператора  процедуры,  в котором содержатся имя процедуры и необходимые параметры.  Операторы. Приведем пример описания процедуры:
             procedure NumString(N: integer; var S: string);
             var
               V: integer;
             begin
               V := Abs(N);
               S := '';
               repeat
                 S := Chr(N mod 10 + Ord('0')) + S;
                 N := N div 10;
               until N = 0;
               if N < 0 then S := '-' + S;
             end;
Описания функций.
Описание функции----заголовок---;---тело----;
Заголовок---function---идентиф./уточнен.идентиф.---список формал.парамет--:---тип результ--;
Тип результ.----идент.типа/string---
 В заголовке функции определяется идентификатор функции, формальные параметры (если они имеются) и тип результата функции. Функция активизируется при вызове функции.  При вызове функции указывается идентификатор функции и какие-либо параметры, необходимые для вычисления функции.  Вызов функции может включаться в  выражения  в  качестве операнда.  Когда выражение вычисляется, функция выполняется и  значением  операнда  становится  значение, возвращаемое функцией.
             function Max(a: Vector; n: integer): extended;
             var
              x: extended;
              i: integer;
             begin
               x := a(1);
               for i := 2 to n do if x < a[i] then x := a[i];
               Max := x;
             end;
Аналогично процедурам функции могут описываться, как с ближним типом вызова (near),  с дальним типом вызова (far), опережающие (forward),  внешние (external),  ассемблерные (assembler) или подставляемые (inline).  Однако функции прерываний (interrupt) не    допускаются.


14 Описания near и far. Borland Pascal  поддерживает  две  модели  вызова процедур ближнюю (near) и дальнюю (far). С точки зрения объема программы и скорости выполнения ближняя модель вызова более эффективна,  но с ней связаны ограничения:  процедуры типа  near  могут  вызываться только в том модуле,  где они описаны. Процедуры же с дальним типом вызова можно вызывать из любого модуля,  но они несколько менее эффективны.  На основе описания процедуры компилятор будет  автоматически  выбирать правильную модель вызова.  Для процедур, описанных в интерфейсной части модуля (interface),  используется дальняя модель вызова - их можно вызывать из других модулей.  Процедуры, описанные в секции реализации модуля  (implementation),  имеют  ближний тип вызова. Вызываться они могут только из программ данного модуля. Чтобы  переопределить  автоматический выбор  модели  вызова компилятором,  можно использовать директиву компилятора {$F+}. Процедуры и функции, компилируемые в состоянии {$F+}, всегда будут иметь дальний тип вызова (far), а в состоянии{$F-} компилятор автоматически  выбирает  корректную  модель.  По  умолчанию используется директива {$F-}.Чтобы задать конкретную модель вызова,  в описании процедуры перед ее блоком можно указать директиву near или far. При наличии такой директивы она переопределяет директиву $F компилятора и автоматический выбор модели вызова.Описания export.Описание export делает процедуру или функцию экспортируемой,  вынуждая компилятор использовать для нее дальний тип вызова и генерировать специальный код входы и выхода из процедуры. Процедуры и функции должны быть экспортируемыми в  следующих случаях: Процедуры и функции экспортируются DLL (динамически компонуемой библиотекой). Процедуры и функции системного вызова в программе Windows. Процедуры и функции экспортируются: процедуры Windows; диалоговые процедуры; процедуры системного вызова для перечисления; процедуры уведомления об обращении к памяти; специализированные процедуры Windows (фильтры).
Описания interrupt. В описании процедуры перед блоком операторов может  указывается директива interrupt.  Процедура в этом случае рассматриваетя, как   процедура   прерывания.  Не может вызываться из операторов процедуры. Для программ под Windows не используется.
Описание forward. Сначала описывается процедура (имя), а само описание в другом месте. Опережающее описание  и  определяющее  описание представляют собой полное описание процедуры.  Процедура считается описанной с помощью опережающего описания . В  интерфейсной  части   модуля   описания forward не допускаются.
             procedure Walter(m,n : integer); forward;
            procedure Clara(x,y : real);
             begin
             end;
             procedure Walter;
             begin
              Clara(8.3, 2.4);
             end;
Определяющее описание  процедуры может быть внешним описанием.  Однако,  оно не может быть внутренним описанием.  Определяющее описание также не может содержать директиву  interrupt,  описания  assembler,  near,   far, export, inline или другое описание forward.
Описания external. Описания external позволяют связывать  отдельно скомпилированные процедуры и функции,  написанные на языке ассемблера. Описания external позволяют также импортировать процедуры и  функции из DLL.
директива external
external------------------------------------------------
	|			             |
  строков.конст.------name-----строк.конст---|
		    index------целая конст--|
Директива external,  состоящая только из  зарезервированного слова  external,  используется  в  сочетании  с  директивами  {$L имя_файла} для компоновки с процедурами и функциями,  реализованными в файлах .OBJ
             procedure MoveWord(var source,dest; count: longint);
               external;
function GlobalAlloc(Flags: Word; Bytes: Longint): THandle;
far; external 'KERNEL' index 15; роль операторной части
Описания assembler.Описания assembler позволяют вам написать всю  процедуру или функцию на ассемблере.
блок asm ---assembler--;--раздел описания--asm оператор
Описания inline. Директивы inline  позволяют записывать вместо блока операторов инструкции в машинном коде. При вызове обычной процедуры компилятор  создает код,  в котором параметры процедуры помещаются в стек,  а затем для вызова процедуры генерируется инструкция CАLL. Когда вы вызываете подставляемую процедуру (inline),  компилятор  генерирует код с помощью директивы inline,  а не с помощью инструкции CALL.
директива inline -->оператор inline 
15 Параметры.В описании процедуры или функции задается  список формальных параметров.  Каждый параметр, описанный в списке формальных параметров,  является локальным по отношению к описываемой  процедуре или функции и в модуле, связанным с данной процедурой или функцией на него можно ссылаться по его идентификатору.
список формальных параметров-----(описание параметра через;)
описание  параметра-----var или const-----список идентиф----:---тип параметра
Существует три типа параметров: значение, переменная и нетипизированная переменная. Они характеризуются следующим:
             1.  Группа  параметров  без  предшествующего ключевого слова является списком параметров-значений.
             2.  Группа параметров, перед которыми следует ключевое слово const и за которыми следует тип,  является списком параметров-констант.
             3.  Группа параметров,  перед которыми стоит ключевое  слово  var и за которыми следует тип,  является списком нетипизированных параметров-переменных.
             4.  Группа  параметров,  перед которыми стоит ключевое слово var или const за которыми не следует тип, является списком нетипизированных параметров-переменных.
Параметры-значения.Формальный параметр-значение  обрабатывается,  как локальная по отношению к процедуре или функции переменная,  за  исключением того, что он получает свое начальное значение из соответствующего фактического параметра при активизации процедуры или функции. Изменения,  которые  претерпевает формальный параметр-значение,  не влияют на значение фактического параметра. Соответствующее фактическое    значение   параметра-значения       должно быть выражением и его значение не  должно  иметь  файловый тип  или  какой-либо структурный тип,  содержащий в себе файловый тип. Фактический параметр должен иметь тип,  совместимый по присваиванию  с  типом формального параметра-значения.Параметры-константы.Формальные параметры-константы работают аналогично локальной переменной, доступной только по  чтению,  которая  получает  свое значение при активизации процедуры или функции от соответствующего фактического  параметра.  Присваивания  формальному   параметру-константе не допускаются.  Формальный параметр-константа также не может передаваться в качестве  фактического  параметра  другой  процедуре или функции. В тех случаях, когда формальный параметр не изменяет при выполнении процедуры или функции своего значения,  вместо  параметра-значения следует   использовать  параметр-константу.  Параметры-константы позволяют при реализации процедуры или функции защититься от случайных присваиваний формальному параметру. Кроме того, для параметров структурного и строкового типа компилятор  при использовании вместо  параметров-значений параметров-констант может генерировать более эффективный код.Параметры-переменные. Параметр-переменная используется,  когда значение должно передаваться из процедуры или функции вызывающей  программе.  Соответствующий фактический параметр в операторе вызова процедуры или функции должен быть ссылкой на переменную. При активизации проце   дуры или функции формальный параметр-переменная замещается фактической переменной,  любые изменения в значении формального  параметра-переменной отражаются на фактическом параметре. Внутри процедуры  или функции любая ссылка на формальный параметр-переменную приводит к доступу к самому фактическому  параметру. Тип фактического параметра должен совпадать с  типом  формального параметра-переменной. Нельзя использовать выражения.
16 Нетипизированные параметры.  Когда формальный параметр является нетипизированным параметром-переменной, то  соответствующий  фактический  параметр  может представлять собой любую ссылку на переменную или константу,  не     зависимо от ее типа.  Нетипизированный параметр, описанный с ключевым словом var,  может модифицироваться, а нетипизированный параметр,  описанный  с  ключевым словом const,  доступен только по чтению. В процедуре  или функции у нетипизированного параметра-переменной тип отсутствует, то есть он несовместим с переменными всех типов,  пока  ему  не  будет  присвоен определенный тип с помощью       присваивания типа переменной.
function Equal(var source,dest; size: word): boolean;
             type

               Bytes = array[0..MaxInt] of byte;
             var
               N: integer;
             begin
               N := 0;
              while (N<size) and (Bytes(dest)[N] <> Bytes(source)[N]
                              do Inc(N);
               Equal := N = size;
             end;

Эта функция может использоваться для  сравнения  любых  двух переменных любого размера. Например, с помощью описаний:

            type
              Vector = array[1..10] of integer;
              Point = record
                        x,y: integer;
                      end;
             var
               Vec1, Vec2: Vector;
               N: integer;
               P: Point;

        и вызовов функций:

             Equal(Vec1,Vec2,SizeOf(Vector))
             Equal(Vec1,Vec2,SizeOf(integer)*N)
             Equal(Vec[1],Vec1[6],SizeOf(integer)*5)
             Equal(Vec1[1],P,4)
  Хотя нетипизированные  параметры  дают вам большую гибкость, их использование сопряжено с некоторым риском.  Компилятор не может проверить  допустимость операций с нетипизированными переменными.1
17 Открытые параметры.Открытые параметры  позволяют передавать одной и той же про       цедуре или функции строки и массивы различных размеров.Открытые строковые параметры. Открытые строковые параметры могут описываться двумя  способами:
- с помощью идентификатора OpenString;
- с помощью ключевого слова string в состоянии {$P+}.
Идентификатор OpenString описывается  в  модуле  System.  Он обозначает специальный строковый тип, который может использоваться только в описании строковых параметров.             Для открытого строкового параметра фактический параметр  может быть переменной любого строкового типа. В процедуре или функции атрибут размера (максимальная  длина)  формального  параметра будет тем же, что у фактического параметра. Открытые строковые  параметры  ведут себя также как параметры-переменные строкового типа,  только их нельзя  передавать  как обычные переменные  другим  процедурам или функциям.  
             procedure AssignStr(var S: OpenString;
             begin
               S := '0123456789ABCDEF';
             end;
Так как S - это открытый строковый параметр, AssignStr можно передавать переменные любого строкового типа:
             var
               S1: string[10];
               S1: string[20];
             begin
               AssignStr(S1);           { S1 := '0123456789' }

               AssignStr(S2);           { S2 := '0123456789ABCDEF' }
             end;
 В следующем  примере  процедура  FillString заполняет строку заданным символом до ее максимальной длины.
procedure FillStr(var S: OpenString; Ch: Char);
             begin
               S[0] := Chr(High(S));         { задает длину строки }
               FillChar(S[1], High(S), Ch);  { устанавливает число
                                               символов }
             emd;
Значения и  параметры-константы,  описанные с использованием идентификатора OpenString или ключевого слова string в  состоянии  {$P+}, не  являются  открытыми строковыми параметрами.  Они ведут себя также,  как если бы были описаны с максимальной длиной стро    кового типа  255. Открытые параметры-массивы.            Формальный параметр, описанный с помощью синтаксиса: array of T является открытым параметром-массивом.  T должно быть идентификатором типа, а фактический параметр должен быть переменной типа T, или массивом,  типом элементов которого является T.  В  процедуре       или функции  формальный  параметр ведет себя так,  как если бы он был описан следующим образом: arra[0..N - 1] of T. Если фактический параметр - это простая переменная типа T,  то он интерпретируется как массив с одним элементом типа T.  К открытому формальному параметру-массиву  можно  обращаться только по элементам.  Присваивания всему открытому массиву не допускаются. Открытый параметр-массив  может  быть  параметром-значением,        параметром-константой и  параметром-переменной. Открытые параметры-массивы помещаются в стэк. Сначала УК-ля на первый элемент фактического параметра, а затем слова с атрибутами размера. Процедура Clear в следующем примере присваивает каждому элементу массива вещественных значений ноль, а функция Sum вычисляет сумму всех элементов массива вещественных чисел. 
procedure Clear(var A: array of Real);
             var
               I: Word;
             begin
               for I := 0 to High(A) do A[I] := 0;
             end;
             function Sum(const A: array of Real): Real;
             var
               I: Word;
               S: Real;
             begin
               S := 0;
               for I := 0 to High(A) do S := S + A[I];
               Sum := S;
             end;

Когда типом элементов открытого  параметра-массива  является Char, фактический параметр может быть строковой константой. При передаче  в  качестве открытого параметра-массива пустая строка преобразуется в строку с одним элементом,  содержащим символ  NULL,  поэтому  оператор  PrintStr('')  идентичен  оператору PrintStr('#0').
18 Процедурные типы. Процедурные типы хранятся в виде двойного слова.  При этом в       младшем слове содержится смещение процедуры,  а в старшем - базовый сегмент. В Borland Pascal допускается интерпретация процедур и функций,  как объектов,  которые можно присваивать переменным и передавать в качестве параметров.  Такие действия можно выполнять с помощью процедурных типов.
процедурный тип
---------procedure---------------------------------------------
|		|список форм.парам.|
|--------function-------------------:----результат---
		|список форм.парам.|
Характерно, что синтаксис записи процедурного типа в точности совпадает с записью заголовка процедуры  или  функции,  только опускается  идентификатор  после  ключевого  слова  procedure или function.  Приведем некоторые примеры описаний процедурного типа:
             type
                Proc = procedure;
                SwapProc = procedure(var X, Y: Integer);
                StrProc = procedure(S: String);
                MathFunc = function(X: Real): Real;
                DeviceFunc = function(var F: text): Integer;
                MaxFunc = function(A, B: Real; F: MathFunc): Real;
Borland Pascal не позволяет описывать функции, которые возвращают значения процедурного типа.  Результат функции должен быть строкового,  вещественного, целого, символьного, булевского типа, указателем  или иметь перечислимый тип,  определенный пользователем. Проц.типы в выражениях. Использование процедурного типа в выражениях означает вызов процедуры. Искл: если нах-ся слева, то присвоение значения. Процедурные значения. Можно использовать оператор присвоения. Значение: nil или ссылка. Константа. Определяет идентификатор функции ли процедуры со своим исходным типом.
19 Основные принципы и этапы объектно-ориентированного программирования. ООП представлено для создания сложного продукта в виде совокупности объектов, каждый из которых является экземпляром. Взаимоотношение осуществляется путем передачи сообщений.
+ Сокращение межмодульных вызовов и уменьшение объема информации. Это достается за счет локализации данных.Улучшается повторность использования кода программ.
Можно создать библиотеки классов. - Некоторое снижение быстродействия.
В основе ООП лежат несколько принципов:
1. абстрагирования – процесс выделения абстракций в предметной области. Уровень абстракций может быть различным. Класс – это некоторая абстракция.
2. ограничение доступа – сокрытие. Не надо что-то знать. Сокрытие разделяется на 2 части: интерфейсная часть – совокупность из вне. Реализация – внутренняя реализация абстракции. Позволяет выполнить разработчики конструирование поэтапно. Сочетание и объединение объектов – инкапсуляция – объединение свойств объекта и скрытие его реализации. 
3. модульность – принцип организации программы, предполагает реализацию отдельных частей. Модули могут выполнять служебную роль. Принцип унаследован от модульного программирования. 
4. иерархичность – упорядочивание системы абстракций.                                                                   2 вида иерархии:                                                                                                                                      1) целая/часть – показывает, что некоторые абстракции включены в рассмотренную абстракцию как часть.                                                                                                                             2) обще/частное – частный случай из общего. 
5. наследование – отношение между абстракциями, при котором 1 абстракция включает в себя 1 или несколько абстракций, порождающих ее. 
6. типизация – ограничение, накладывание на свойства объектов и препятствие взаимозаменяемости абстракций различных типов. Жесткая степень типизации. Раннее обнаружение ошибок, на стадии компиляции. Упрощение документирования. Возможность генерации более эффективного кода. 
7. параллелизм – свойство нескольких абстракций находится в активном состоянии одновременно.
8. устойчивость – свойство абстракции сущ-ть во времени, не зависимо от процесса, породившего данный объект.                                                                                              Различают временные объекты. Хранящие промежуточный результат нескольких действий. Локальные объекты, сущ-е внутри программ. Глобальные – пока программа работает. Сохраняемые – данные хранятся в файлах. 
Этапы: 
1) анализ и уточнение спецификаций.                                                                             Цель – max полное описание задачи. Входит: анализ предметной области задач, объектная декомпозиция систем, определяет важные особенности поведения объектов, разрабатывает программу, показывает основные абстракции предметной области и сообщения перед-е между ними.
2) Проектирование.                                                                                              Различают 2 аспекты:                                                                                                       - логическое проектирование (решение не зависит от условий эксплуатаций). Разработка структуры класса, определяет поля для хранения составляющих состояний объектов, алгоритмы методов. Использует специальные приемы разработки классов (наследование). Результат: иерархия/диаграмма классов, отображения взаимосвязь классов.                                                                                           – физическое проектирование (учитывается взаимодействие со внешней средой). Объединение классов в модули, выбор схемы и подключ. Определение способа взаимодействия с оборудованием, ОС, программ обеспечением, обеспечение синхронизации процессов.
3) Реализация. Поэтапный процесс подключения классов к проекту. Получаемый проект показывается заказчику. Выясняются все неточности. Проходит тестирование и отладка программы.
4) Модификация – изменение неких свойств.     
20 Объектная декомпозиция. При использовании технологии ООП решение представляется в виде результата взаимодействия отдельных элементов некоторой системы. В такой системе каждый функциональный элемент, получив некоторое входной воздействие (сообщение) в процессе решения задачи, выполняет заранее определенные действия. Процессом решения управляет последовательность сообщений. Передовая эти сообщения от элемента к элементу, система выполняет необходимые действия. Функциональные элементы системы, параметры и поведение которой определяются условием задачи, обладающие самостоятельным поведением, получили название объектов. Процесс представления предметной области задачи в виде совокупности объектов, обменивающихся сообщениями, называется объектной декомпозицией. Декомпозиция может быть нескольких уровней. Объектная декомпозиция сложных предметных областей. Между объектами существует 2 типа связи: ассоциация (связь между разнотипными объектами). Может иметь направление. Обобщение (-- однотипными). Характеристики объекта неизменяемые. Объект студент Петров так им и будет.
21 Объекты и сообщения. В ООП программе предметная часть задачи реализуется в виде совокупности объектов, которые взаимодействуют через передачу сообщений. Каждый объект, получая сообщения, должен определенным образом на них реагировать, выполняя заранее определенные для него действия. Состояние объекта характеризуется набором конкретных значений некоторого перечня всех возможных свойств данного объекта. Как правило, набор свойств в процессе функционирования не изменяется, а меняются лишь конкретные значения этих свойств. Поведение объекта характеризуется определенным набором реакций на получаемые события и часто зависит от состояния объекта. Объекты, обладающие сходными состояниями и поведением, образуют группу. Для получения информации о состоянии объекта ему посылается сообщение – запрос. В ответ на запрос объект пересылает отправителю требуемую информацию. В таких случаях говорят, что над объектом выполнена операция селекции. Передача сообщений. 1 вид. Один объект использует другой объект. Объект, передающий сообщение – актиный, принимающий – пассивный. Может быть объект-посредник. 2 вид. Объект является результатом декомпозиции более сложного объекта. Между ними операция включения.
22 Объектные типы. Объектный тип является структурой, сотстоящей из фиксированного числа компонентов. Объект – обобщение типа запись. Объектный тип может наследовать компоненты другого типа. Внутренний формат данных объекта имеет сходство с внутренним форматом записи.  Поля объекта записываются в порядке их описаний как непрерывная последовательность переменных.  Любое поле, унаследованное от родительского (порождающего) типа, записывается перед новыми полями, определенными в дочернем (порожденном) типе. 
Объект-------object--------------список компонентов--private------------end-----
                   |наследование|                          |список комп| 
                                                            Мб пустым   
Список методов----заголовок метода-----------------------;--------
               ^                  |-;--virtual--|               |
		|                              |целая конст|     |
		| ---------------------------------------------- |
23 Область действия объекта. Область действия идентификатора элемента,  описанного в объектном типе,  простирается от точки описания до конца определения  объектного типа и распространяется на все дочерние объектные типы  и  блоки всех описаний методов объектного типа.  Область действия идентификаторов элемента включает десигнаторы  поля  и  операторы       with над ссылками на переменную данного объектного типа.
24 Константы объектного типа. При описании  константы  объектного типа используется тот же синтаксис, что и при описании константы типа запись. Значения для элементов (компонентов) метода задаваться не могут. С учетом приводимых ранее описаний объектных типов, приведем некоторые примеры констант объектного типа:
             const
                ZeroPoint: Point = (X: 0; Y: 0)
                ScreenRect: Rect = (A: (X: 0; Y: 0); B: (X: 80; Y: 25);
Константы объектного типа,  которые содержат виртуальные методы,  не требуется инициализировать с помощью вызова конструктора. Эта инициализация автоматически выполняется компилятором.
25 Создание экземпляров объектов. Экземпляр объекта  создается посредством описание переменной или константы  объектного  типа  или путем применения стандартной процедуры New к переменной типа указатель на объектный  тип.  Результирующий объект называется экземпляром объектного типа.
             var
             F: TField;
             Z: TZipField;
С учетом этих описание  переменных  F  является  экземпляром TField, а Z - экземпляром TZipField. Если объектный тип содержит виртуальные методы, то экземпляры  этого  объектного  типа должны инициализироваться посредством вызова конструктора перед вызовом любого виртуального метода. Ни же приведен пример:
             var
               S: StrField;
             begin
               S.Init (1, 1, 25, 'Первое имя');
               S.Put ('Френк');
               S.Display;
               ...
               S.Done;
             end;
Присваивание экземпляра  объектного  типа  не  подразумевает инициализации экземпляра. Объект инициализируется  кодом,  генерируемым  компилятором, который выполняется между вызовом конструктора,  и когда выполнение фактически достигает первого оператора в блоке кода конструктора. Если экземпляр объекта не инициализируется,  и проверка диапазона включена (директивой {$R+}),  то первый вызов виртуального метода экземпляра объекта дает ошибку этапа выполнения. Если проверка диапазона выключена (директивой {$R-}), то первый виртуального метода неинициализированного объекта может привести  к  непредсказуемому поведению. Указатель на объектный тип является совместимым по  присваиванию с указателем на любой родительский объектный  тип,  поэтому во  время  выполнения  программы указатель на объектный тип может указывать на экземпляр этого типа или на экземпляр любого  дочернего типа.
26 Динамические переменные объектного типа. Стандартные процедуры  New  и  Dispose  допускают в качестве второго параметра вызов конструктора или деструктора для  выделения для памяти переменной объектного типа  или  ее  освобождения.При этом используется следующий синтаксис:
             New(P, Construct)
             Dispose(P, Destruct)
где P - это указатель на  переменную,  ссылающийся  на  объектный тип, а Construct и Destruct - это вызовы конструкторов и деструкторов объектного типа. Можно также использовать New как функцию, распределяющую и возвращающую динамическую переменную заданного размера:
            New(T)
        или
             New(T, Construct)
В первой форме T может быть любым ссылочным типом. Во второй форме T должен указывать на объектный  тип,  а  Construct  должен  быть вызовом  конструктора  этого объекта.  В обоих случаях типом езультата функции будет T. Приведем пример:
             var
               F1, F2: PField
             begin
               F1 := New(PStrField, Init(1, 1, 25, 'Имя'));
               F1 := New(PZipField, Init(1, 2, 5, 'Почтовый индекс', 0,
                          99999));                   
                   .
                   .
               WriteLn(F1^.GetStr);       { вызывает TStrField.GetStr }
               WriteLn(F2^.GetStr);       { вызывает TZipField.GetStr }
                   .
                   .
                   .
               Dispose(F2, Done);         { вызывает TField.Done }
               Dispose(F1, Done);         { вызывает TStrField.Done }
             end;
27 Методы.Описание метода  внутри объектного типа соответствует опережающему описанию метода (forward). Таким образом, где-нибудь после описания объектного типа, но внутри той же самой области действия, что и область действия описания объектного типа, метод должен реализоваться путем определения его описания. Если требуется уникальный идентификатор метода, то используется уточненный идентификатор метода. Он состоит из идентификатора типа объекта, за которым следуют точка и идентификатор метода. Как и любому другому идентификатору,  идентификатору  уточненного метода, если требуется, могут предшествовать идентификатор пакета  и точка.
уточненный идентификатор метода—идент. объект.типа---.---идентиф.метода
Описания методов. Описание метода внутри объектного типа соответствует  опережающему  описанию  (forward) этого метода.  Таким образом,  метод  должен быть реализован где-нибудь после описания объектного  типа и внутри той же самой области действия метода путем определяющего описания. Для процедурных и функциональных методов определяющее описания  имеет форму обычного описания процедуры или функции,  за тем исключением,  что в этом случае идентификатор процедуры или функции рассматривается как идентификатор метода. Для методов конструкторов и деструкторов определяющее описаний принимает форму описания процедурного метода, за тем исключением,  что  зарезервированное слово procedure заменяется на зарезервированное слово constructor или destructor. Определяющее описание  метода может повторять (но не обязательно) список формальных параметров заголовка метода в объектном типе.  В этом  случае заголовок  метода должен в точности повторять заголовок в объектном типе в порядке, типах и именах параметров и в типе возвращаемого функцией результата, если метод является функцией. В определяющем  описании  метода всегда присутствует неявный параметр с идентификатором Self,  соответствующий формальному параметру-переменной, обладающему объектным типом. Внутри блока метода Self представляет экземпляр,  компонент метода которого  был указан  для  активизации метода.  Таким образом,  любые изменения значений полей Self отражаются на экземпляре. Если используется несколько методов, то используется оператор with. По умолчанию все методы статические. Все, кроме конструктора могут быть виртуальными. Метод виртуальный, если директива virtual. Компилятор разрешает ссылки на статические методы во время компиляции. Вызовы виртуальных разрешаются в момент выполнения – «позднее связывание».
28 Активизация методов. Метод активизируется посредством оператора вызова  процедуры   или функции, состоящего из десигнатора метода, за которым следует список параметров. Такой тип вызова называется активизацией метода.
десигнатор метода-------------------------------------идентиф.метода---------
                               |---ссылка на переем---.--|
Ссылка на переменную задается, если десигнатор метода должен описывать экземпляр объектного типа,  а идентификатор метода должен обозначать метод этого объектного типа.            Для статических  методов описанный тип (на этапе компиляции) определяет, какой из методов активизируется. Для виртуальных методов выбором экземпляра управляет  фактический тип (этапа выполнения). В операторе with,  ссылающемся на экземпляр объектного типа, ссылка на  переменную  в  десигнаторе метода может опускаться.Активизация уточненных методов.В методе, операторе вызова функции или процедуры для обозначения активизации конкретного  метода  допускается  использование десигнатора уточненного метода. Такой тип вызова называется активизацией уточненного метода.
десигнатор уточненного метода
	|---идентифик.объектного типа----.-------идент.метода-----
	|---inherited---------------------------------|
Объектный тип,  заданный  в  десигнаторе уточненного метода, должен быть таким же,  как и включающий метод объектный тип,  или соответствовать родительскому типу. Для обозначения родительского объектного типа или объектного  типа, включающего   метод,   можно  использовать  ключевое  слово inherited;  в методах объектного типа, не имеющего предка, ключевое слово inherited использоваться не может. Активизация уточненных методов  не  предусматривает механизма диспетчеризации виртуальных методов - вызов будет всегда статическим и всегда вызывает заданный метод. Активизация уточненного метода используется обычно в переопределяющем методе  для  активизации  переопределяющего метода.
29 Соглашения о вызовах методов. Методы используют те же соглашения о вызовах,  что и обычные процедуры и функции,  за тем исключением,  что каждый метод имеет неявный дополнительный параметр Self, который соответствует параметру-переменной того же типа,  что и объектный тип данного метода. Параметр Self всегда передается последним и всегда имеет форму 32-разрядного  указателя на экземпляр,  из которого вызывается метод. Во время возврата метод должен удалить параметр Self из стека точно так же, как он удаляет обычные параметры. Методы всегда используют дальний тип вызова,  независимо  от состояния директивы $F компилятора.
30 Виртуальные методы.По умолчанию,  методы являются статическими,  однако они могут, за исключением конструкторов, быть виртуальными (посредством включения директивы virtual в описание метода). Компилятор разрешает ссылки на вызовы статических методов во время процесса  компиляции, тогда как вызовы виртуальных методов разрешаются во время выполнения. Это иногда называют поздним связыванием. Если объектный тип объявляет или наследует какой-либо виртуальный метод,  то переменные этого типа должны быть инициализированы  посредством вызова конструктора перед вызовом любого виртуального метода.  Таким образом,  объектный тип, который описывает  или наследует виртуальный метод,  должен также описывать или наследовать по крайней мере один метод-конструктор.           Объектный тип может переопределять любой из методов, которые он  наследует от своих родителей.  Если описание метода в потомке указывает тот же идентификатор метода,  что и описание  метода  в родителе, то описание в потомке переопределяет описание в родителе. Область действия переопределяющего метода расширяется до сферы действия потомка, в котором этот метод был введен, и будет оставаться таковой,  пока идентификатор метода не будет переопределен снова. Переопределение статического  метода не зависит от изменения        заголовка метода. В противоположность этому, переопределение виртуального метода должно сохранять порядок,  типы и имена параметров,  а также типы результатов функций, если таковые имеются. Более  того,  переопределение  опять  же  должно включать директиву virtual.
31 Динамические методы. Borland Pascal поддерживает дополнительные методы с  поздним       связыванием, которые  называются динамическими методами.  Динамические методы отличаются от виртуальных только характером их диспетчеризации на этапе выполнения. Во всех других отношениях динамические методы считаются эквивалентными виртуальным. Описание динамического метода эквивалентно  описанию  виртуального метода,  но описание динамического метода должно включать в себя индекс динамического метода,  который  указывается  непосредственно за ключевым словом virtual. Индекс динамического метода  должен  быть  целочисленной  константой  в  диапазоне от 1 до 656535 и должен быть уникальным среди индексов других  динамических методов,  содержащихся в объектном типе или его предках. Например:   procedure FileOpen(var Msg: TMessage); virtual 100;       Переопределение динамического  метода должно соответствовать  порядку, типа и именам параметров и  точно  соответствовать  типу результата функции  порождающего  метода.  Переопределение  также должно включать в себя директиву virtual,  за которой следует тот       же индекс динамического метода, который был задан в объектном типе предка.
32 Конструкторы и деструкторы. Конструкторы и деструкторы являются специализированными формами методов.  Используемые в  связи  с  расширенным  синтаксисом стандартных  процедур  New и Dispose,  конструкторы и деструкторы обладают способностью размещения и удаления  динамических  объектов. Кроме того, конструкторы имеют возможность выполнить требуемую инициализацию объектов,  содержащих виртуальные методы. Как и все другие методы,  конструкторы и деструкторы могут наследоваться,  а объекты могут содержать любое число конструкторов и  деструкторов.            Конструкторы используются  для инициализации вновь созданных объектов. Обычно инициализация основывается на значениях, передаваемых  конструктору в качестве параметров.  Конструктор не может быть виртуальным.
Описание конструктора-----заголовок конструктора---;----блок подпрограммы---;---
Заголовок конструктора----constructor-----идентиф.-----------------------------------------------
	  
 |уточн.идент.метода----список форм.параметров|           constructor Field.Copy(var F: Field);
             begin
               Self := F;
             end;
Деструкторы являются противоположностями конструкторов и используются для очистки объектов  после  их  использования. Обычно очистка состоит из удаления всех полей-указателей в объекте.
             destructor Field.Done;
             begin
               FreeMem(Name, Length (Name^) + 1);
             end;
             destructor StrField.Done;
             begin
               FreeMem(Value, Len);
               Field.Done;
             end;
Деструктор дочернего  типа,   такой   как   указанный   выше TStrField.Done, обычно  сначала  удаляет  введенные в порожденном типе поля указателей,  а затем в качестве последнего действия вызывает соответствующий сборщик деструктор непосредственного родителя для удаления унаследованных полей-указателей объекта.
33 Определение класса.Упрощение состоит в том, что в языке предусмотрены заготовки классов. Языки программирования предусматривают реализацию свойств классов. Класс – некая абстракция неких объектов. Класс – структурный тип классов включает поля. Как класс связан с конкретной действительностью?
                                                                                         Объкт-переменная
Объект                                                                                    имя
абстр-я                                  класс                                         параметры
имя сост-я поведение 	        имя                                  методы
                                                       поля
                                                       методы                  
                                                                 
                                                                                                  имя
                                                                                                 параметры
                                                                                                  метод
Ограничение доступа.Инкапсуляция – ограничение доступа. Наличие инкапсуляции гарантирует повреждение из вне. Объект может быть создан и уничтожен. Создание объекта может быть динамическое и статическое.         
34 Полиморфизм. Наследование. Наследование – отношение между классами. Добавление новых полей/методов. Исходный класс – родитель. Порожденный – потомок. Если родители единственны, то наследник – простой, иначе – сложный. Получается иерархичное дерево. Все, что наследуется, все может использоваться. Простой полиморфизм. «Поли» - много. Различие реализации единого метода. Различают несколько терминов:Чистый полиморфизм – 1 код функции может по-разному интерпретироваться в зависимости от типа входных параметров. 
Перезагрузка – 1 имя функции, а выполняется совершенно другая функция. Она может быть параметрической, зависеть от переменных. Переопределение.Сложный полиморфизм при создании полиморфных объектов. Для расширенных возможностей Pascal и C указателю на объект класса родителя может указывать указатель класса-потомка.1) При передаче объекта класса-потомка.2) При работе с динамическими величинами. Тип полиморфного объекта становится известным на стадии выполнения программы. Механизм позднего связывания. Методы позднего связывания – виртуальные методы. Даст возможность неявно изменить код программы. В объекте 2 методы: Print, Out. Метод  Out вызывает метод Print. Реализация осуществляется с использованием специальных таблиц – виртуальных. Метод создается для всех у кого есть виртуальный метод. По ней вызывается метод. При использование полиморфных объектов возникает проблема с доступами к полям объекта, описанием в классе потомки. Указатель на объект родитель связан с описанием. 
35 Динамические объекты. Динамические объектные типы. Переменные объектного типа могут быть статичекими или динамическими, т.е. располагаться в сегменте данных (статические) или в куче (динамические). Перепишем нашу программу, используя динамические объекты.
код.
uses crt;
Type
  _A = Object
    per:integer;
    constructor Init;
    procedure P; virtual;
    procedure run;
  end;
  _B = Object(_A)
    constructor INIT;
    procedure P; virtual;
  end;
constructor _A.INIT;
  begin per:=0 end;
Procedure _A.P;
  begin end;
procedure _A.RUN;
  begin P end;
constructor _B.INIT;
  begin per:=0 end;
Procedure _B.p;
  begin per:=5; writeln(per) end;
Var
  A:_A; B:_B;
Begin
  Clrscr;
  B:=New(_B.INIT);
  B^.run;
end.
Инициализация динамической переменной B реализуется с помощью функции New. В этом случае первым параметром указывается имя типа инициализируемой переменной, а вторым осуществляется вызов метода-конструктора. Такой прием характерен для техники ООП. При этом распределение объектов в динамической памяти происходит одновременно с инициализацией ТВМ.
36 Создание библиотек классов.Современный стиль программирования предполагает многократное использование кода, содержащегося в библиотеках. Объектно-ориентированные языки программирования облегчают создание библиотек классов. Получающиеся в результате библиотеки являются гибкими, им присущ высокий уровень абстракции. Эти библиотеки могут быть расширены путем добавления новых классов, а также путем образования новых классов на основе уже существующих. При этом новые классы наследуют функциональность существующих классов. В каркасе .NET Framework представлено более 2500 классов, содержащих повторно используемый код. Эти классы доступны в любом языке программирования, который поддерживается платформой. Библиотека классов .NET Framework является расширяемой На основе уже существующих базовых классов можно создать новые производные классы, причем производные классы могут быть реализованы на совершенно другом языке программирования. В состав библиотеки классов .NET Framework, входят классы, которые используются при разработке Windows-приложений, Web-приложении, а также приложении с базами данных. В библиотеке классов .NET Framework имеются также классы, обеспечивающие взаимодействие с языком XML, с моделью компонентных объектов Microsoft (COM) и с любой платформой, поддерживающей интерфейс 32-разрядных Windows-приложении (Win32 API).
37 Композиция и наполнение. Композиция. В результате объектной декомпозиции 2го и далее уровней могут быть получены новые объекты, которые находятся в состоянии включения (можно организовать и наследование, композиция, наполнение). Композиция – 1 является частью другого. Она реализуется включенным в класс поля, является объектом другого объекта. Если элементов иного, то используют композицию или наполнение. Наполнение – включение объектов в некоторый класс можно реализовать не с помощью объектов, а с помощью указателей.
38 Модули.Программа Borland Pascal может  использовать  блоки  кода  в программных модулях.  Модуль  (unit)  можно рассматривать как мини-программу, которую может использовать ваша прикладная программа. Как и программа, он имеет заголовок  и основной блок, ограниченный begin и end. Основной блок любой программы Borland Pascal может  включать в себя  строку, позволяющую программе использовать один или более модулей. 
             program Colors;
             uses Crt;
             begin
                .
                .
                .
             end.
Библиотеки исполняющей системы Borland Pascal включают в себя несколько модулей, которые вы найдете весьма полезными. Например, благодаря  использованию модулей Dos или WinDos. Вы можете  также писать свои собственные модули.  Применяйте их для разделения больших программ на логические связанные  фрагменты. Программный код,  который вы помещаете в модуль, может использоваться любой программой.  Вам нужно написать  исходный  код только один раз, а затем вы сможете много раз его использовать.
39 Синтаксис модулей. Модули являются основой модульного программирования. Они используются  для  создания  библиотек,  которые могут включаться в различные программы .
модуль-------заголовок модуля----;---интерфейсный раздел----раздел реализации----раздел инициализации---.----
Заголовок модуля. В заголовке модуля определяется имя модуля.
Заголовок модуля----unit----идентиф.модуля------
Имя модуля используется при ссылке на модуль  при использовании. Это имя должно быть уникальным, так как два модуля с одним именем не могут одновременно использоваться. Имя исходного  файла  модуля и двоичного файла должны совпадать с идентификатором модуля,  усеченным до первых  8  символов. Если это  не  так,  то  компилятор не сможет найти исходный и/или двоичный файл при компиляции использующей этот модуль программы. Интерфейсная секция. В интерфейсной секции описываются те константы,  типы, переменные,  процедуры и функции,  которые являются  глобальными,  то есть доступными основной программе. Основная программа имеет доступ к этим элементам, как если бы они были описаны в модуле, являющимся вложенным по отношению к данной программе.
интерфейсная секция
interface---------------------------------------------------------------------------------------
 	|оператор uses|------|раздел описания констант/описания типов пременных/раздел     
                   описания переменных/раздел оисания заголовков процедур и функций|
раздел заголовков процедур и функций---------заголовок процедуры----;------------------------------
                                                                              |заголовок функции|            |директива inline|--;--|

Секция реализации. В секции реализации определяются модули всех глобальных процедур или функций. В ней также описываются константы, переменные, процедуры и функции,  являющиеся локальными, то есть недоступными основной программе.
Секция реализации
Implementation------------------------------------------------------раздел описаний-------
                              |оператор uses|
По механизму действия описания процедур и функций  в  интерфейсная  секция аналогична опережающему описанию,  хотя директива forward не указывается.  Таким образом,  эти процедуры и  функции могут  быть определены (и к ним можно обращаться в любой последо  вательности) в секции реализации. Допускается дублирование заголовков процедур  и  функций  из интерфейсной  части.  
Секция инициализации. Секция инициализации является последней секцией  модуля. Она       может  состоять либо из зарезервированного слова end (в этом случае модуль не содержит кода инициализации),  либо из  операторной части, которая должна выполняться для инициализации модуля.
Секция инициализации-------------------end-----------------
			|операторная часть|
40 Совместное использование описаний. Можно модифицировать процедуру WriteXY таким образом,  чтобы она воспринимала дополнительный параметр,  задающий прямоугольное окно на экране:      procedure WriteXY(SomeWindow : WindRec;
                               X, Y :       integer;
                               Message :    string);
             procedure ShowError(Somewindow : WindRec; ErrMsg : string);
Нужно учитывать,  что две процедуры находятся в разных модулях. Даже если вы описываете WindData в интерфейсной секции одного модуля,  то нет такого допустимого способа, с помощью которого это описание могло бы быть доступно в другом модуле. Решение состоит в том,  чтобы описать третий модуль,  в  котором  содержится только определение записи WindRec:
             unit WindData;
             interface
             type
               WindRec = record
                          X1, Y1, X2, Y2 : integer;
                          ForeColor,
                          BackColor      : byte;
                          Active         : boolean;
                         end;
             implementation
             end.
В добавление к тому, что модификация кода процедур WriteXY и  ShowError  позволяет использовать новый параметр,  в интерфейсной  секции  модулей  Display  и  Error  теперь  может  использоваться WindData.  Это  допустимо,  так как модуль WindData не зависит от        своего оператора uses, а модули Display и Error ссылаются друг на друга только в соответствующих секциях реализации. Взаимозависимые модули могут быть полезны в отдельных ситуациях, но использовать их надо аккуратно. Если вы будете применять  их так, где это не требуется,  программу станет сложней обслуживать, и она будет больше подвержена ошибкам.
41 Библиотеки DLL. Использование DLL. Динамически компонуемые  библиотеки (DLL) позволяют нескольким прикладным программа Windows или DOS защищенного режима  совместно использовать код и ресурсы. В Borland Pascal вы можете как  использовать существующие DLL,  так и написать  свои  собственныеDLL, которые можно применять в других программах. Использование DLL. Чтобы модуль мог использовать процедуру или функцию  в  DLL, он должен  импортировать процедуру или функцию с помощью описания     external. Например,  в следующем описании из DLL и именем  KERNEL  (ядро Windows) импортируется функция с именем GlobalAlloc:
 function GlobalAlloc(Glags: Word; Bytes: Longint): THandle;  far; external 'KERNEL' index 15;
В импортируемой процедуре или функции директива external занимает место описательной и операторной части, которые нужно было бы включить в противном  случае.  В  импортируемых  процедурах  и функциях должна  использоваться дальняя модель вызова,  выбранная     ключевым словом far или директивой компилятора {$F+}; во всем остальном их поведение не отличается от обычных процедур и функций. Borland Pascal  импортирует процедуры и функции тремя способами:
             - по имени;
             - по новому имени;
             - по порядковому номеру.
Формат директив external для каждого из трех методов показан в приведенном ниже примере.
 Когда оператор index или name не указан, процедура или функция экспортируются по имени.  Это имя совпадает с идентификатором процедуры или  функции.  
             procedure ImportByName; external 'TESTLIB';
Когда задан оператор name,  процедура или функция импортируется  под именем,  отличным от имени идентификатора.
             procedure ImportByName; external 'TESTLIB'name 'REALNAME'
Наконец, при  наличии  оператор  index процедура или функция импортируется по порядковому значению. Такой вид импорта уменьшает время  загрузки модуля,  так как отпадает необходимость поиска имени  в  таблице  имен  DLL.  В  следующем   примере   процедура
        ImportByOrd импортируется из библиотеки 'TESTLIB':
             procedure ImportByOrd; external 'TESTLIB' index 5;
Имя DLL  задается  после  ключевого слова external,  а новое имя, заданное в операторе name,  не  обязано  представлять  собой строковые литералы.  Допускается  любое строковое выражение-константа. Аналогично,  порядковый  номер,  задаваемый  в   операторе index, может быть любым целочисленным выражением-константой.
             const
                TestLib = TestLib;
                Ordinal = 5;
             procedure ImportByName; external TestLib;
             procedure ImportByName; external TestLibname 'REALNAME'
             procedure ImportByOrd; external TestLib index Ordinal;
 Хотя DLL может содержать переменные, импортировать их в другие модули невозможно.  Любой доступ к переменным DLL должен осуществляться через процедурный интерфейс.
42 Модули импорта. Описания импортируемых процедур и функций  могут  помещаться
        непосредственно в программу, которая их импортирует. Однако обыч-
        но они объединяются в модуль импорта,  содержащий  описания  всех
        процедур и функций в DLL, а также все типы и константы, необходи-
        мые для интерфейса с DLL. Модули импорта не обязательны для интерфейса  с  DLL,  но
        они значительно  упрощают обслуживание использующих множество DLL
        проектов.
             unit DateTime;
             interface
             type
               TTimeRec = record
                   Second: Integer;
                   Minute: Integer;
                   Hour: Integer;
               end;
             type
               TDateRec
                  TDateRec = record
                    Day: Integer;
                    Month: Integer;
                    Year: Integer;
                  end;
             procedure SetTime(var Time: TTimeRec);
             procedure GetTime(var Time: TTimeRec);
             procedure SetDate(var Date: TDateRec);
             procedure GetDate(var Date: TDateRec);
             inplementation
             procedure SetTime; external 'DATETIME' index 1;
Когда вы компилируете использующую DLL программу, компилятор не ищет DLL,  так что ее присутствие  не  требуется.  Однако  DLL должна присутствовать в системе при выполнении программы. Если вы пишете собственные DLL, они не компилируются автоматически при компиляции использующей ее программы с помощью команды Compile¦Make. DLL следует компилировать отдельно.
43 Статический и динамический импорт. Директива external обеспечивает возможность статического импорта процедур и функций из DLL.  Статически импортируемая процедура и функция всегда ссылается на одну и ту  же  точку  входа  в DLL. Расширения  Windows и защищенного режима DOS Borland поддерживает также динамический импорт,  при котором имя DLL и имя  или порядковый номер  импортируемой процедуры или функции задается во       время выполнения.  Приведенная ниже программа ShowTime использует динамический импорт  для вызова процедуры GetTime в DATETIME.DLL. Обратите внимание на использование переменной  процедурного  типа для представления адреса процедуры GetTime.
             program ShowTime;
             uses WinProcs, WinTypes, WinCrt;
             type
               TTimeRec = record
                   Second: Integer;
                   Minute: Integer;
                   Hour: Integer;
               end;
               TGetTime = procedure(var Time: TTimeRec);
             var
               Time: TTimeRec;
               Handle: THAndle;
               GetTime: TGetTime;
             begin
               Handle := LoadLibrary('DATETIME.DLL');
               if Handle >= 32 then
               begin
                 @GetTie := GetProcAddress(Handle, 'GETTIME');
                 if @GetTime <> nil then
                  begin
                    GetTime(Time);
                    with Time do
                      WriteLn('Текущее время: ', Hour, ':', Minute, ':',
                               Second);
                   end;
                   FreeLibrary(Handle);
                 end;
             end;



44 Директива процедуры export. Если процедуры и функции должны  экспортироваться  DLL,  они должны компилироваться с директивой компилятора export. Директива export принадлежит к тому же семейству процедурных директив,  что  и near,  far,  inline  и interrupt.  Это означает,  что директива export, если она присутствует,  должна указываться  перед  первым заданием процедуры или функции - она не может указываться в определяющем описании или в опережающем описании. Директива export делает процедуру или  функцию  экспортируемой. Она  принудительно  использует  для подпрограммы дальний тип вызова и подготавливает ее для экспорта,  генерируя для процедуры специальный код входа и выхода.  Заметим, однако, что фактический     экспорт процедуры или функции не происходит, пока подпрограмма не перечисляется в операторе exports библиотеки.
45 Оператор exports. Процедура или функция экспортируется DLL, когда она указывается в операторе exports библиотеки.

         оператор exports
         ¦   ----------   -----------------            ----
         L-->¦ exports +-->¦ список экспорта+----------->¦ ; +------->
             L----------   L-----------------            L----

                              -----------------
         список экспорта --T->¦ запись экcпорта+----------->
                           ¦  L-----------------  ^
                           ¦        ----         ¦
                           L------->¦ ; +----------
                                    L----

         оператор exports
           ¦    ----------------
           L--->¦ идентификатор +--T------------------------------------
                L----------------  ¦   --------  ------------------ ^ ¦
                                   L-->¦ index +->¦ целая константа +-- ¦
                                       L--------  L------------------   ¦
         ----------------------------------------------------------------
         L-T-------------------------------------T---------------------->
           ¦ -------   ---------------------- ^¦  -----------  ^
           L>¦ name +-->¦ строковая константа +--L->¦ resident +---
             L-------   L----------------------     L-----------

     Оператор exports  может встречаться в любом месте описательной части программы или библиотеки и любое число раз.  Каждая запись в операторе exports задает идентификатор экспортируемой процедуры или функции. Однако, эта процедура или функция должна описываться до оператора exports, и ее описание должно содержать директиву export.  Перед идентификатором в операторе exports вы можете указать  идентификатор модуля с точкой;  это называется полностью уточненным идентификатором. Запись экспорта может также включать в себя оператор  index, который состоит из ключевого слова index,  за которым следует целочисленное значение в диапазоне от 1 до  32767.  Когда  задается оператор index,  для  экспортируемой процедуры или функции должно использоваться специальное порядковое  значение.  Если  в  записи экспорта оператор index отсутствует, то порядковое значение присваивается автоматически. Запись может содержать оператор name, состоящий из ключевого слова name,  за которым следует строковая константа.  При наличии оператора name экспортируемая процедура или функция  должна  экспортироваться с  помощью  задаваемого строковой константой имени. Если оператор name в записи экспорта  отсутствует,  то  процедура  или функция экспортируется по ее идентификатору (символы которого преобразуются в верхний регистр). Наконец, запись экспорта может включать в себя ключевое слово resident.  При  задании ключевого слова resident информация об экспорте остается в памяти, пока DLL загружена. Параметр resident существенно уменьшает время поиска подпрограммы в DLL по имени.
46 Код инициализации библиотеки.Операторная часть  библиотеки  состоит из кода инициализации библиотеки. Код  инициализации  выполняется  только  один раз при    первоначальной загрузке библиотеки. Когда другие прикладные программы будут использовать уже загруженную библиотеку,  код инициализации повторно не выполняется, но увеличивается счетчик использования DLL.  DLL хранится в памяти,  пока ее счетчик использования больше        нуля. Когда  счетчик использования становится нулевым,  указывая, что все использующие DLL прикладные программы  завершили  работу, она удаляется из памяти. При этом выполняется код процедуры выхода. Код инициализации  DLL обычно выполняет такие задачи как регистрация класса окна для содержащихся в DLL оконных  процедур  и установка начальных значений для глобальных переменных DLL. Установив в нулевое значение переменную ExitCode,  код  инициализации библиотеки может указать состояние ошибки.  По умолчанию ExitCode равна 1,  что указывает на успешную инициализацию. Если код инициализации устанавливает значение этой переменной в 0,  то DLL выгружается из системной памяти,  и вызывающая прикладная программа уведомляется  о  неудачной     загрузке DLL. После разгрузки DLL экспортируемая функция вызывает процедуру WEP (процедура выхода Windows)  DLL,  если  она  присутствует. Библиотека Borland Pascal автоматически экспортирует функцию WEP,  которая продолжает вызывать записанный в переменной ExitProc  адрес,  пока ExitProc не примет значения nil.  Поскольку этот меха      низм процедур выхода соответствует работе с процедурами выхода  в программах Borland Pascal, и в программах, и в библиотеках вы можете использовать одну и ту же логику процедур выхода. Поскольку операционная система при завершении DLL переключает внутренний стек, процедуры выхода в DLL должны компилироваться  с запрещением проверки стека (в состоянии {$S-}). Кроме того, если в  процедуре  выхода  DLL  происходит ошибка этапа выполнения, операционная система аварийно завершает работу,  поэтому  вы  для предотвращения  ошибок этапа выполнения вы должны включить в свой код достаточное количество проверок.
47 Глобальные переменные и файлы в DLL. Как правило,  DLL не является "владельцем" каких-либо открываемых ей  файлов  или получаемых ей от системы глобальных блоков      памяти. Такими объектами владеет (прямо или косвенно) сама  прикладная программа, вызывающая DLL. Когда прикладная программа завершает работу,  любые открытые        файлы, владельцем которых она является,  автоматически закрываются, а  все принадлежащие ей глобальные блоки памяти автоматически освобождаются. Это означает, что описатели данных файлов и блоков  памяти, записанные  в DLL в глобальных переменных,  могут в любое        время стать недопустимыми без уведомления DLL.  По  этой  причине        DLL не  следует полагаться на допустимость описателя файла и глобальных описателей памяти,  хранящихся между обращениями к DLL  в  глобальных переменных. Такие описатели следует сделать параметрами процедур и функций  DLL,  и  вызывающая  прикладная  программа должна отвечать за их поддержку. В Windows глобальные блоки памяти,  распределенные с атрибутом gmem_DDEShare (определенные в модуле  WinTypes),  принадлежат DLL, а  не  вызывающим прикладным программам.  Такие блоки памяти остаются распределенными, пока они явно не освобождаются DLL, или пока DLL не выгружается.
48 Ошибки этапа выполнения в DLL. Если в  DLL  происходит ошибка этапа выполнения,  вызывающая DLL прикладная программа завершает работу.  При этом сама DLL  необязательно удаляется  из  памяти,  поскольку она может использоваться другими прикладными программами. Поскольку DLL не может знать,  вызывается ли она из приклад    ной программы  Borland Pascal или из прикладной программы,  написанной на другом языке программирования, то DLL не может вызывать  процедуры выхода  прикладной  программы  до завершения прикладной программы. Прикладная программа просто прерывается и  выгружается  из памяти.  По  этой причине,  чтобы таких ошибок не происходило,  нужно обеспечить в DLL достаточное количество проверок. Если в DLL под Windows происходит ошибка  этапа  выполнения, то надежнее всего полностью выйти в Windows. Если вы просто пытаетесь модифицировать и перестроить сбойный код DLL, а затем снова выполнить прикладную программу,  Windows не будет загружать новую версию,  если ошибочная версия уже находится в память. Выйдите из Windows  и перезапустите ее,  а Borland Pascal обеспечит загрузку корректной версии DLL.
49 Создание совместно используемых DLL. Borland Pascal поддерживает DLL, которые могут совместно использоваться в защищенном режиме DOS и в Windows.  Совместно  используемые DLL совместимы на уровне двоичного кода. Это означает, что один и тот же файл .DLL  может  использоваться  в  прикладной программе защищенного  режима  DOS  или  в  прикладной  программе Windows. При компиляции совместно используемой DLL в качестве целевой     платформы нужно выбирать Windows:
             * В  IDE выберите команду Compile¦Target и в диалоговом окне
               Target (Целевая платформа) укажите Windows.
             * При использовании компилятора,  работающего в  режиме  ко-
               мандной строки,  для  выбора  в качестве целевой платформы
               Windows используйте переключатель /CW.
DLL, скомпилированная  для  защищенного  режима   DOS,   под Windows использоваться  не может,  так как библиотека исполняющей системы защищенного режима DOS использует отдельные  функциональные вызовы DOS и DPMI, которые следует избегать в Windows.             Совместно используемая  DLL может взаимодействовать с операционной системой (DOS защищенного режиме или Windows) только  через модуль  WinAPI.  Этот модуль представляет функции,  общие для  защищенного режима DOS  и  Windows.  Другие  интерфейсные  модули        Windows, такие  как WinTypes и WinProcs,  описывают большое число подпрограмм API, не поддерживаемых в защищенном режиме DOS. Важно отметить,  что  хотя  совместно используемая DLL может выполняться одновременно и под Windows, в окне защищенного режима Windows DOS,  связь  через  DLL между двумя операционными средами невозможна. Реально в системе будет присутствовать две копии DLL, каждая из  которых защищена от другой и использует полностью изолированную область памяти. 
50 Объектная модель Delphi. Основные принципы и средства реализации модели.
Основные свойства:
1. ограничение доступа к полям и методам за счет определения каждого интерфейса. 5 типов секций.
2. более развитые механизмы реализации полиморфных методов
3. средства работы с метаклассами
4. возможность делегирования методов
51 Определение класса в Delphi.
Все классы, используемые в Delphi? наследуются из класса tObject. Формат описания нового класса выглядит следующим образом:Type <имя обл. класса> class(<имя родителя>);
Разделы описания
Private <скрытые элементы>
Protected <защищенный элемент>
Public <общедоступный элемент>
Published <опубликованный элемент>
Automated <элемент реализующий OLE-механизмы>
end;
Если имя родителя не указано, то родитель tObject. 
Секция Private создает внутренние элементы, обращение к которым возможно только в пределах модуля. 
Protected - создает защищенные элементы.
Public – общедоступный элемент может образоваться из любой части программы.
Published – по ограничению доступа.
Визуальные компоненты информации становятся доступными к Object инспектору.
Automated – создает элементы доступные в любом месте. Для элементов этой секции генерируется дополнительная информация.
Секцию имеет смысл объявлять для потомка класса tObject. Потомки класса могут менять область доступа элементов. Все элементы динамические. Операция ^ не используется.
Вызовы конструктора и деструктора становятся обязательны, так как конструктор выполняет размещение объекта памяти. Можно изменить несколько функций. 
Если конструктор и деструктор не указывается, то они наследуются от родительского класса  tObject. При создании собственного конструктора необходимо перед программированием специф. операций обращаться к наследующему элементу. 
Constructor TNum. Create;
	Begin
		Inherited Create;
			n := an
	end;
Если константа вызывает существующий объект, поля не обнуляются.
Деструктор вызывает CleanUpInstance используется для корректного завершения программ; вызывает Instancesize освобождает память. В классе tObject деструктор объявлен виртуальным. 
Free – вызывает деструктор. 
При работе с объектом необходимо помнить – все переменные являются указателями. 

Var A, B: TNum   |   A               B
                              |   nil              nil
                              |
A:= Tnum.Create  |   A               B        
                              |   .                nil
                              |       объект
                              |            
B:= A                    |   A                 B
                              |     .                .
                              |        объект
                              |
B.Destoy               |     A                B
                              |      .                 .
                              |               ^
                              |                .
                              |
A.Destoy               |      A                B
A.Free                   |         .               .
                              |                ^
                              |                 .
52 Особенности реализации полиморфизма в Delphi.
Существуют методы: виртуальные, динамические и абстрактные. Параметрическая перезагрузка. 
Виртуальный метод 
Динамический метод называет полиморфизм виртуального метода. Доступ осуществляется через специальные таблицы динамических методов. При изменении используется overwrite. Таблица динамических методов хранит адреса виртуальных методов. Этот метод используется, если класс имеет много потомков. Абстрактный метод используется для методов, реализация которых откладывается. Описывается служебным словом abstract и обязательно переопределяется в потомок класса. Создавать объект абстрактного класса запрещается. 
53 Свойства в Delphi. Средства Delphi позволяет определить интерфейс доступа к полям класса. 
4 вида: 
1. простые
2. свойства массивы
3. индексированные свойства
4. процедурные свойства
54 Метаклассы в Delphi. Метаклассы некого типа переменные, значения которых являются классы. Ссылка на класс – метакласс.
Type <имя типа ссылки> = class
Of <базовый тип>;
Var <имя переменной>: <имя типа ссылки>;
TClasss. Базовый класс tObject. Стандартно определена ссылка.
Операция  is. 
Когда возникает неоходимость проверки принадлежности объекта к классу.
Синтаксис: 
<Имя объекта> is <имя класса>
Результат логический
Операция as.
Используется, когда тип объекта может отличаться от типа использованной переменной для обеспечения доступа к скрытым полям и методам. Проверка возможности преобразования типа. Сравнивается тип реального объекта и исполняемого класса. 
55 Делегирование в Delphi. Имеется возможность объявления указаний на методы. При объявлении типа используется специальный идентификатор of Object. 
type TMyMetod = function (as: integer) of Object;
TMyClass = class
public TMetod: TMyMetod;
end;
type TMyCClass = class
private
FMetod: TMyMetod;
public
property Metod: TMyMetod read FMetod write FMetod;
end;
Такие свойства процедурные. С использованием процедурных свойств осуществляется делегирование, которое позволяет определить различные изменения делегированного класса. Возможно динамическое делегирование. 
56 Библиотека стандартных классов в Delphi.
                                          TObject

                                   …………………..

                              ………………………....



57  Создание и обработка сообщений и событий в Delphi.
1. описать тип сообщения в разделе тип.
2. объявить индекс или номер сообщения
3. инициировать/передать сообщение
Сообщение в Delphi.
Оно состоит из нескольких полей. Первое сообщение: Msg, должно содержать индекс сообщения. Далее следуют поля передаваемого сообщения. Последнее поле используют для записи сообщений. Оно может отсутствовать. 
type TMessage = record
Msg: Cardinal;
case integer of
0: (WParam: longint;…);
1: (WParam:…);
end;
end;
Можно создать собственное сообщение.
Методы обработки сообщений.
Если для объекта не определен обработчик, то проверяется таблица динамических методов базового класса.
Генерация сообщений.
Существует 3 способа передачи сообщений:
1. через очередь сообщений с ожиданием завершения используется функция SendMessage. Возвращает результат обработки сообщения, в котором зарегистрировано сообщение. 
2. для передачи сообщения без ожидания конца обработки – PostMessage. Список параметров совпадает с предыдущей функцией. Ставит сообщение в очередь. True – постоянно в очереди, иначе - False.
3. обработка без очереди – PerForm.
58 Обработка исключений в Delphi. В Delphi можно перехв-ть аварийное завершение программы. Автономное формирование специального блока информации. Доступ через спец. классы. Класс – родитель всех сообщений: exeption.
Нек-е спец-но перех-ся стандартными программами; (деление на 0). 
Средства обработки:
1. специальная конструкция языка
2. иерархия классов различных исключений
3. оператор генерации исключений
4. операторы обработки исключений. 
Фрагменты программ с искл-ми опис-ся 2 конструкции:
fry…finale;
fry…except;
fry<операторы после которых может возникнуть исключения сист-я> finale <котрое выполняется после>
2я конструкция: если необходимо выполнить действия, которая аннулирует после исключения.
Создание, генерация, обработка исключений.  
59 Разработка приложений в Delphi.4.0. Разработка приложения
Состоит из двух этапов:
- Создание интерфейса приложения,
- Определение функциональности приложения.
Для создания интерфейса необходимо:
- выбрать нужные компоненты;
- определить внешний вид и функциональные возможности компонентов;
- отобразить окно Инспектора Объектов;
- расположить компоненты на форме.
Для обеспечения функциональности приложения необходимо:
- задать в Инспекторе Объектов значения свойств и процедур обработки событий;
- написать программный код для заданных процедур обработки событий.
4.1. Простейшее приложение  
Представляет собой заготовку, обеспечивающую все необходимое для приложения. Это:
- форма, для которой уже созданы два файла с описанием и модулем.
При создании приложений в форму помещаются компоненты, для них устанавливаются свойства и создаются обработчики событий. 
К простейшему приложению разработчик добавляет новые формы.


